Q6.a) What was the most difficult part of this worksheet. Explain why you found it difficult, and how you managed to overcome this (if at all).

The most difficult part of this worksheet was the rotate function. I found it difficult because I didn't understand why the sonic needed to be translated back to the origin to begin with. I was also unsure about what the order to rotate it was. The worksheet says that they are multiplied in reverse order, but I couldn't make sense of that. I thought that would mean that the sonic sprite would move further away from the origin instead of towards it because the from origin matrix was being multiplied first, since the code was transformMatrix = fromOriginMatrix * rotateMatrix * toOriginMatrix;. To overcome this, I asked chatGPT to explain by giving it my code. It explained that if I reversed the order of multiplication, what would happen is that it would rotate the sprite first, before translating it to the origin and back again, which would likely result in a different rotation behaviour, which is nto what I want. 


b) Choose a matrix topic that you are still unsure about. Explain that topic, and steps you will take to clarify your doubts. You will be graded on how well you analyse your problem with understanding that topic. (150)

A matrix topic I am not so sure about is rotation by matrix multiplication. I do not really understand how the rotation matrix is derived, as in why certain values are just 0 in the matrix and when rotating different angles the matrix changes. To clarify I just watched this video on rotation matrix for 2d vectors (https://www.youtube.com/watch?v=fH5MJT3HI58&ab_channel=PhysicsNinja). I learned from the video that the length can be rewritten to include the angle theta using the trigo rules TOA CAH SOH. The angle of the new position you want to rotate to is expressed as theta + alpha (theta being the angle you want to rotate it by, alpha being the angle from the x axis), which is where the expression cos(theta + alpha) comes from and where the trigo expansion rules come in. The matrix which contains elements like cos(theta) sin(theta) is actually derived from the expanded trigo position you want to rotate to. 

As to why the matrix has to be translated back to origin, I asked chat gpt to explain. What I gathered is that because when you rotate, it rotates relative to the coordinate system's origin. How I visualised it was if I were to rotate straight away and the sprite was at (10, 10), when I rotate it 90 degrees counter-clockwise, the sprite would be at (-10,10) (might not be accurate). Instead of rotating on the spot as I thought it would before, it rotates relative to the origin. That's why it is important to translate the sprite back to the origin first so that it is rotated properly before translating it back to its original position. 

c) Write a reflection about this worksheet. You may like to include how effectived it is to motivate and help you learn, how well it relates to game development, etc. (150)

I don't think I was as confused by this worksheet as I was with the vectors worksheet. I was able to understand a bit more exactly what I was trying to do, although I still struggled. With the vectors worksheet I had no idea what I was even trying to do with the HVectors and all the new terms. I think with the matrix multiplication, transformation and scaling I understood a bit better what it was that I had to do because there were formulas and step by step instructions on how to properly manipulate the matrices. I did struggle trying to put that into code because although I felt like I knew relatively what I had to do on paper, actually doing it in code was a bit difficult. I also was confused on the LHS and how it affected the order of multiplication. I also find math particularly boring, which did not motviate me much and led to me procrastinating quite a bit. I think this is very useful for game development, especially when you need to calculate physics. Although there may be packages that handle all the physics stuff for you, I still think it's important to understand how it works in case something goes wrong or you want to implement/modify things a certain way. 